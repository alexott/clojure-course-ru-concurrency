#+TITLE: Конкуретное и параллельное программирование в Clojure
#+AUTHOR: Alex Ott 
#+EMAIL: alexott@gmail.com
#+DATE:
#+DESCRIPTION: конспект лекций для курса о Clojure
#+KEYWORDS: Clojure, Concurrency

#+LANGUAGE: ru
#+FILETAGS: :Clojure:Talks:

 - look to:
   - [ ] http://skillsmatter.com/podcast/clojure/you-came-for-the-concurrency-right
   - [ ] http://aphyr.com/posts/306-clojure-from-the-ground-up-state

* О чем пойдет речь?

** О чем пойдет речь?

Доброе время суток.  Меня зовут Алекс Отт, и рад возможности рассказать вам о конкуретном
и параллельном программировании в Clojure.

Поддержка конкуретного и параллельного программирования в Clojure - это одна из самых
привлекательных особенностей данного языка.  За счет того, что эта поддержка встроена в
сам язык, то написание конкуретных программ становится достаточно простым делом.

Эта часть курса состоит из нескольких разделов:
 - Сначала мы рассмотрим как устроено конкуретное программирование в Clojure в целом
 - Затем мы разберем разные средства работы с изменяемыми данными - ссылки,
   атомы, агенты и т.д.
 - После этого мы обратим внимание на поддержку параллельного выполнения кода используя
   как встроенные средства, так и возможности JVM
 - И в последнем разделе мы вкратце рассмотрим некоторые возможности и пакеты, которые
   имеют отношение к конкуретному и параллельному программированию.

Для данной части курса будет предложено небольшое домашнее задание.

* Concurrency in Clojure: The big picture

Как вы уже знаете, все данные в Clojure по умолчанию являются неизменяемыми и операции над
ними дают новую структуру данных.  Но бывают ситуации, когда вам надо изменить какое-то
значение, и сделать это изменение видимым для других частей программы.

В императивных языках это сделать очень легко - переменная меняется на месте, и все ок.
Но если вы работаете с данными из нескольких потоков, то на вас сразу наваливается
множество проблем - вам нужно как-либо гарантировать что изменения будут сделаны атомарно,
что другие потоки не увидят неконсистентных данных и т.д.  На помощь приходят локи для
защиты переменных и т.п., но если вам нужно делать изменения в нескольких местах, то тут
могут навалиться и другие проблемы, как дедлоки и т.д.

Одна из причин этой проблемы заключается в том, что в императивных языках состояние
переменной тесно связано с ее identity (именем) - это неразрывное целое - нет понятия
истории состояний переменной в конкретные моменты времени, так что все изменения видны
всем частям программы которые пользуются данными полученными в конкретный момент времени.
Чтобы избежать проблем при работе с изменяемыми данными, в Clojure при доступе к значению,
программы получают снапшот состояния переменной с данным именем в конкретный момент
времени.  Если в следующий момент времени нам надо установить новое значение, то имя
связывается с новым состоянием, а предыдущие снапшоты не изменяются. 

Это можно изобразить в виде следующего графика: 

TODO:


Вы также можете думать об identity как о указателе на текущее состояние, так что при
изменении происходит установка указателя на новое значение без изменения оригинального
значения. 

Использование такого подхода делает конкуретное и параллельное программирование в Clojure
достаточно простой задачей.

Имеется отличная [[http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey][лекция Рича Хики]] где он рассказывает о Identity, State & Time.  Если у
вас будет время, то советую посмотреть ее.

* Изменяемое состояние

Существует несколько видов изменяемых данных в Clojure, которые можно классифицировать по
разным признакам: synchronous/asynchronous, и coordinated/non-coordinated, и т.д.

|------------------+--------------+-------------|
| Вид изменения    | Синхронное   | Асинхронное |
|------------------+--------------+-------------|
| Координированное | ссылки (ref) | -           |
| Независимое      | атом         | agent       |
| Изолированное    | var          | -           |
|------------------+--------------+-------------|

Для доступа к изменяемым данным используется функция =deref=, а поскольку она используется
очень часто, то для нее имеется специальный макрос процедуры чтения: =@=.  Но об этом
операторе мы поговорим подробней в следующих разделах.

В качестве примера совместного использования ссылок и агентов, вы можете посмотреть на
программу =ants=, которую Рич Хики использовал для демонстрации возможностей Clojure в
части конкуретного и параллельного программирования.

** Ссылки (references)

Давайте начнем рассмотрение изменяемого состояния с ссылок (refs).

Как уже упомяналось ранее, ссылки поддерживают координированное, синхронное изменение
данных на базе Software Transaction Memory (STM).  Вы можете думать об изменениях
происходящих в рамках ссылок также как о транзакциях которые выполняются в обычных
реляционных базах данных.  Единственное отличие от СУБД заключается в том, что ссылки не
реализуют durability - сохранение данных в долгосрочной памяти.  Все остальные свойства
СУБД сохранены - atomicity, consistence, isolation.   

Также как и во многих базах данных, транзакции Clojure основаны на Multiversion
concurrency control (MVCC), когда Clojure в момент начала транзакции "захватывает"
состояние переменных, которые используются в транзакции, и использует эти значения на
протяжении всей транзакции.  Когда вычисление заканчивается, то Clojure пытается внести
сделанные изменения, и если какая-либо из переменных уже была изменена, то транзакция
откатывается и начинается снова.  (Хочется отметить, что вы можете контролировать
количество повторов транзакции, с помощью параметров при создании ссылки, но об этом чуть
позже).  Подробно об устройстве STM в Clojure вы можете прочитать в [[http://java.ociweb.com/mark/clojure/article.html][статье]] указанной в
разделе "Ресурсы"

Общий синтаксис объявления ссылок выглядит следующим образом:

#+BEGIN_SRC clojure
(ref x & опции)
#+END_SRC

В качестве =x= вы можете использовать любой из нужных типов данных.  Вы также можете
указать различные опции, например, связать метаданные с нужной ссылкой, добавить
функцию-валидатор, или проконтролировать размер истории изменений.  Подробную информацию
вы можете найти в [[http://clojure.org/refs][официальной документации]].

В общем виде, изменение значений ссылок происходит следующим образом: вы начинаете
транзакцию с помощью =dosync=, и выполняете блок кода внутри этой транзакции.  Блок кода
может использовать разные функции для изменения данных: =alter=, =commute= или =ref-set=.

TODO: Add picture from http://sw1nn.com/blog/2012/04/11/clojure-stm-what-why-how/ (добавить credit)


В качестве примера, давайте рассмотрим следующий кусок кода:

#+BEGIN_SRC clojure
(defn transfer-money [from to amount]
  (dosync
   (if (< @from amount)
     (throw (IllegalStateException. (str "Account has less money that required! "
                                         @from " < " amount)))
     (do (alter from - amount)
         (alter to + amount)))))
#+END_SRC

Эта функция может использоваться следующим образом:

#+BEGIN_SRC clojure
(def ^:private acc-1 (ref 1000))
(def ^:private acc-2 (ref 1000))

user=> (transfer-money acc-1 acc-2 500)
1500
user=> @acc-1
500
user=> @acc-2
1500
#+END_SRC

Если транзакция была завершена успешно, то в качестве результата будет возвращено значение
последнего выражения, но надо принимать во внимание различие между =commute= & =alter= (и
=ref-set=).

Когда мы используем =alter= в транзакции, и кто-то изменил ту же самую ссылку до того, как
наша транзакция закончилась, то транзакция будет выполнена еще раз (как минимум), пока мы
не сможем сохранить наши изменения.  Но в некоторых случаях, изменение данных достаточно
простое, и не имеет значения в каком порядке изменения были сделаны в разных транзакциях,
т.е. изменения коммутативны.  Для таких ситуаций, в Clojure предусмотрена функция
=commute=, которая может применять коммутативные изменения к ссылкам.  Стоит отметить, что
хотя =commute= изменит значение переменной внутри транзакции, но оно будет применено
только к копии внутри транзакции, а не к актуальному значению - к нему функция будет
применена только при завершении транзакции, и не играет роли то, что кто-то уже изменил
значение или нет (тут стоит отметить, что значение возвращенное из блока кода, может
отличаться от актуального значения ссылки).  Так что в результате использования =commute=
над ссылками, мы никогда не получаем конфликтов, так что транзакции никогда не будут
повторяться, что может вести к значительным улучшениям производительности.

Например, у нас может быть простая функция, которая добавляет деньги на депозит:

#+BEGIN_SRC clojure
(defn add-to-deposit [to amount]
  (dosync
   (commute to + amount)))
#+END_SRC

В том случае, если мы используем =alter= или =ref-set=, транзакция может повторена, если
кто-то изменил значение. Поскольку блок кода может выполняться несколько раз, то он не
должен содержать побочных эффектов, например операций ввода-вывода.  Для упрощения
контроля за кодом, который имеет побочные эффекты, в Clojure имеется специальный макрос
=io!=, который выбросит исключение, если он исполняется в рамках транзакции.  С его
помощью вы можете избежать ошибок, используя неправильную функцию в транзакциях.
Применение кода может выглядеть следующим образом:

#+BEGIN_SRC clojure
(defn write-log [log-msg]
  (io!
   (println log-msg)))
#+END_SRC

В некоторых случаях, вам может понадобиться прервать транзакцию и не повторять ее,
например, если вы обнаруживаете некоректные входные данные.  В этом случае, вы можете
просто сгенерировать исключение, и транзакция будет прервана.  В некоторых случаях, делать
проверку в каждом блоке может не иметь смысла, и для почти всех примитивов изменения
данных введена возможность задания функции-валидатора (с помощью параметра =:validator=
при объявлении ссылки), которая будет вызвана при изменении значения.  Но об этом мы
поговорим отдельно.

TODO:
 - [ ] add about =ensure=
 - [ ] написать про кол-во историй, кол-во откатов и т.п.

** Атомы

Атомы - более простой в использовании способ организации изменяемого состояния.
Существует множество случаев когда вам не нужно координировать изменение нескольких
состояний, а просто внести изменение в какое-то одно - в этом случае атом является
идеальным решением.

Использовать атомы очень просто - создайте инстанс атома с помощью функции =atom= передав
ей некоторое начальное значение, а потом просто вызывайте функцию =swap!= передав ей имя
атома, и функцию которая к нему будет применена (а также дополнительные параметры для этой
функции, если они необходимы).  Синтаксис =swap!= совпадает с синтаксисом =alter=, но не
требует старта транзакции. В качестве результата функция =swap!= возвращает новое значение
атома.

Стоит отметить, что функция не должна иметь побочных эффектов, поскольку если она может
быть выполнена несколько раз, если во время ее выполнения, кто-то другой изменит состояние
атома.  

TODO: нарисовать схему применения атомов? как в книжке от oreilly?

Давайте посмотрим на пример со именованными счетчиками, которые можно увеличивать,
уменьшать и сбрасывать в начальное значение.  Реализация может выглядеть следующим образом:

#+BEGIN_SRC clojure
(def ^:private counters-atom (atom {}))

(defn inc-counter [name]
  (swap! counters-atom update-in [name] (fnil inc 0)))

(defn dec-counter [name]
  (swap! counters-atom update-in [name] (fnil dec 0)))

(defn reset-counter [name]
  (swap! counters-atom assoc name 0))
#+END_SRC

Тут все достаточно просто - мы имеем один атом, который содержит map в котором хранятся
счетчики. Для увеличения или уменьшения счетчиков используется функция =update-in= которая
применяется к текущему состоянию.  Для того, чтобы убрать проверку на наличие счетчика,
вместо =inc= & =dec= тут используется функция-враппер =fnil=, которая подставляет значение
0 если счетчика с таким именем еще не существует.  Реализация-же =reset-counter= очень
проста - она просто устанавливает значение слота map в нужное значение.

В дополнение к функции =swap!=, которая изменяет состояние атома применяя к нему функцию,
для работы с атомами существует и функция =reset!= которая позволяет явно установить
значение атома в нужное значение.  Также имеется и низкоуровневая функция
=compare-and-set!= которая установит атом в новое значение, только если он сейчас равен
указанному старому значению (я не думаю, что эта функция будет использоваться в вашем коде).

Также как и ссылки, при создании атома вы можете указать (с помощью параметра
=:validator=) функцию которая будет проводить валидацию изменяемых данных (если данные
неправильные, то функция должна вернуть =false= или сгенерировать исключение).
Аналогично, вы можете добавить и функции-наблюдатели, которые будут вызваны при изменении
значений.

Кроме того, Вы также можете связать метаданные с атомом - для этого, передайте map в с
необязательным параметром =:meta=.

** Агенты

В отличии от предыдущих двух типов изменяемого состояния, которые были синхронными, агенты
производят изменения асинхронно - вы вызываете функцию для изменения состояния, и она
будет применена в какой-то момент в будущем.  Агенты удобно использовать когда у вас есть
какое-то центральное состояние, которое можно последовательно изменять из разных потоков
выполнения.  Важным отличием агентов от других примитивов является то, что выполняемый код
может содержать побочные эффекты, такие как ввод-вывод (вы, например, можете использовать
агенты для централизованного сбора и сохранения логов).  Агенты также часто используются
для неявной параллелизации кода (хорошим примером является web crawler из книги Clojure
Programming).

*** Использование агентов

Процесс использования агентов очень прост - вы создаете агент, с некоторым начальным
состоянием, с помощью функции =agent=, а затем изменяете его с помощью функций =send= или
=send-off=.  Обе эти функцию имеют одинаковый синтаксис, похожий на синтаксис =swap!= или
=alter= - вы указываете имя агента, а также передаете функцию которая будет применена к
текущему состоянию агента и результат ее выполнения будет использоваться в качестве нового
состояния агента.

Обе функции возвращают управление немедленно, не дожидаясь применения изменений.  Функции
указанные пользователем выполняются в порядке вызова =send= и =send-off=, последовательно
применяясь к текущему состоянию агента.  Главное различие между этими двумя функциями
заключается в том, что код переданный в =send= выполняется в пуле потоков выполнения
фиксированного размера, а для кода переданного =send-off= используются потоки выполнения
из пула потоков который не ограничен в размерах (тот же что и для future).  Так что
рекомендуется, чтобы код выполняемый =send= не выполнял никаких длительных вычислений и не
вызывал функции которые могут привести к блокировке выполнения (например, функции
ввода/вывода).  (В Clojure версии 1.5 стало возможным явно задать пулы потоков выполнения
для =send= & =send-off=, а кроме того, появилась функция =send-via=, которая позволяет
указать пул в котором должен выполниться этот код.

TODO: нарисовать схему применения агентов? как в книжке от oreilly?

Давайте перепишем наш пример со счетчиками используя агенты:

#+BEGIN_SRC clojure
(def ^:private counters-agent (agent {}))

(defn a-inc-counter [name]
  (send counters-agent update-in [name] (fnil inc 0)))

(defn a-dec-counter [name]
  (send counters-agent update-in [name] (fnil dec 0)))

(defn a-reset-counter [name]
  (send counters-agent assoc name 0))
#+END_SRC

TODO: рассказать про код...

Хочется отметить, что вы можете использовать функции =send= & =send-off= как в
транзакциях, так и внутри блоков кода, который выполняется в агенте (вложенные =send=).
Но при этом надо помнить о том, что в этих случаях выполнение =send= откаладывается до
момента когда транзакция будет успешно закончена (т.е.  гарантируется что =send= не будет
выполнен несколько раз), или блок кода выполняемый агентом будет завершен.

В некоторых случаях вам может понадобиться выполнить =send= или =send-off= изнутри блока
кода исполняемого агентом.  Для упрощения этой задачи, и чтобы сделать функции
независимыми от конкретных названий переменных содержащих агенты, внутри блока кода можно
использовать переменную =*agent*=, которая будет ссылаться на текущий агент.

*** Обработка ошибок

Поскольку, в отличии от атомов и ссылок, агенты работают асинхронно, то необходима
возможность как-то обрабатывать ошибки во время выполнения кода.  Как и для других
примитивов, вы можете задать функцию-валидатор которая будет проверять состояние агента, и
не разрешать "плохие" значения.

Но кроме этого, ошибки могут возникать и по другим причинам, например, ошибки
ввода/вывода, или какая-то из функций сгенерирует исключение.  В случае возникновения
ошибки агент переходит в состояние "произошла ошибка" и все последующие вызовы =send=
будут приводить к возврату первой ошибки.  Например:

#+BEGIN_SRC clojure
user=> (def err-agent (agent 1))
#'user/err-agent
user=> (send err-agent (fn [_] (throw (Exception. "we have a problem!"))))
#<Agent@8e7da60 FAILED: 1>
user=> (send err-agent identity)
Exception we have a problem!  user/eval1227/fn--1228 (form-init6590526999427540299.clj:1)
#+END_SRC

Вы по прежнему сможете использовать последнее состояние (используя =deref=), которое было
установлено перед возникновением ошибки.  С помощью функции =agent-error= вы можете
получить исключение которое вызвало ошибку, и на основании этой информации принять решение
о продолжении работы.  Вы также можете заново разрешить использование агента с ошибкой -
используйте функцию =restart-agent= и передайте ей новое начально состояние агента.  В том
случае, если какие-то действия были в очереди этого агента, то они будут применены, но это
не всегда желательно, так что =restart-agent= может принимать опциональный флаг
=:clear-actions= со значением =true= - в этом случае все ожидающие действия будут удалены.

Вы также можете просто игнорировать возникающие ошибки - для этого достаточно при создании
агента указать флаг =:error-mode :continue= (значение по умолчанию равно
=:error-mode :fail=).  Вы также можете указать функцию-обработчик ошибок - используя флаг
=:error-handler= при создании агента, или с помощью функции =set-error-handler!=.  При
использовании функции-обработчика ошибок у вас даже может быть возможность избирательног
игнорирования ошибок, поскольку вы можете переключить агента в режим =:fail= с помощью
функции =set-error-mode!=

#+BEGIN_SRC clojure
user=> (def err-agent (agent 1 :error-mode :continue))
#'user/err-agent
user=> (send err-agent (fn [_] (throw (Exception. "we have a problem!"))))
#<Agent@76aa3e9a: 1>
user=> (send err-agent inc)
#<Agent@76aa3e9a: 2>
user=> @err-agent
2
#+END_SRC

*** Ожидание окончания обработки и т.п.

У вас могут быть ситуации когда вам необходимо дождаться завершения задач, посланных
какому-то из агентов - например, если вы хотите выполнить корректное завершение приложения
или т.п.  Для этого существует 2 функции =await= & =await-for=.  Первая функция блокирует
текущий поток выполнения до тех пор пока не завершаться все посланные задачи, кроме того
она навсегда заблокирует выполнение в случае если агент находится в состоянии "ошибка" или
он был перезапущен с очисткой очереди действий.  Чтобы избежать бесконечной блокировки,
стоит воспользоваться второй функцией -- она принимает дополнительный параметр: сколько
времени надо ждать, и если возник таймаут, то она возвращает =false=.

В то время как функции =await= & =await-for= работают с индивидуальными агентами, есть
возможность остановить работу всех агентов разом -- просто вызовите функцию
=shutdown-agents=, и пулы потоков используемых агентами выполнят все текущие задачи, но
прекратят принимать новые задачи (стоит отметить, что этот же пул используется и для
futures).

** Vars (переменные)

Вы уже встречались с vars в предыдущих лекциях.  Vars это не переменные в том смысле как
они понимаются в других языках программирования.  Существует ограниченная возможность
изменения vars: вы можете либо изменить базовое (top-level значение) -- для всех потоков
выполнения, или изменить значение в конкретном потоке выполнения.

*** Изменение vars для потока выполнения

Иногда вам может понадобиться написать функции чье поведение может зависить от какого-то
глобального состояния????  Хорошим примером таких функций являются функции ввода/вывода,
например, =print= и т.п., которые по умолчанию выводят данные на экран, но также могут
использоваться для вывода в файлы.  Этого можно достичь, например, явно передавая имя
канала вывода информации, но тогда вам придется явно писать =(print stdout XXX)= чтобы
просто вывести что-то на экран.  Не очень-то и комфортно, и не особо гибко.  В текущей
реализации функция =print= берет канал вывода из переменной =*out*=, который по умолчанию
указывает на канал стандартного вывода (экран), но она также может указывать и на другие
каналы вывода, такие как файл и т.п.

В данном примере =*out*= -- динамическая переменная, которая может быть переопределена для
конкретного потока выполнения, не затрагивая другие потоки выполнения.  Для динамических
переменных существует специальное соглашение о именовании - они должны начинаться и
заканчиваться символом звездочка, например, =*test-var*=.  Если вы попробуете определить
обычную переменную с таким именем, то компилятор выдаст ошибку!  Но одного имени
недостаточно -- переменная должна иметь флаг =:dynamic= в метаданных.

После того, как вы создадите динамическую переменную, вы можете изменять ее значение для
текущего потока выполнения - для этого имеется макрос =binding=, по синтаксису аналогичный
=let=, но который устанавливает новые значения для указанных динамических переменных.
Изменения сделанные с помощью =binding= будут видны в коде находящегося внутри =binding=,
включая и вызываемые функции.

Давайте посмотрим как это работает:

#+BEGIN_SRC clojure
(def ^:dynamic *test-var* 20)

(defn print-var [txt]
   (println txt *test-var*))

(defn run-thread [x]
  (.run (fn []
            (print-var (str "Thread" x "before:"))
            (binding [*test-var* (rand-int 10000)]
              (print-var (str "Thread" x " after:"))))))

user=> (doseq [x (range 3)] (run-thread x))
Thread0before: 20
Thread0 after: 6955
Thread1before: 20
Thread1 after: 7022
Thread2before: 20
Thread2 after: 3380
#+END_SRC


Если вы хотите изменить значение которое было уже переопределенно с помощью =binding=, вы
можете воспользоваться функциями =set!= или =var-set=. Например:

#+BEGIN_SRC clojure
(defn run-thread2 [x]
  (.run (fn []
          (binding [*test-var* (rand-int 10000)]
            (println "Thread " x " var=" *test-var*)
            (set! *test-var* (rand-int 10000))
            (println "Thread " x " var2=" *test-var*)))))

user=> (doseq [x (range 3)] (run-thread2 x))
Thread  0  var= 3693
Thread  0  var2= 4408
Thread  1  var= 3438
Thread  1  var2= 2624
Thread  2  var= 6193
Thread  2  var2= 2265
#+END_SRC

Мы можем использовать =set!= для установки значений, которые уже переопределены с помощью
=binding=, но мы не можем это сделать напрямую:

#+BEGIN_SRC clojure
(defn run-thread3 [x]
  (.run (fn []
          (set! *test-var* (rand-int 10000))
          (println "Thread " x " var2=" *test-var*))))
#+END_SRC

*** Изменение базового (top-level) значения var

В некоторых случаях нам может понадобиться изменить "базовое" значение переменной - на
этот случай у нас есть функция =alter-var-root= которая берет переменную, и применяет к
ней указанную функцию:

#+BEGIN_SRC clojure
user=> *test-var*
20
user=> (alter-var-root #'*test-var* (constantly 10))
10
user=> *test-var*
10
#+END_SRC

Заметьте, как мы передаем переменную -- мы не можем просто указать =*test-var*=, поскольку
прямое использование приведет к возврату значения хранящегося в этой переменной, а не
самой переменной.  Мы используем макрос процедуры чтения =#'var-name=, и это аналогично
прямому вызову функции =(var var-name)=.  Также, =alter-var-root= не присваевает значение
напрямую, а получает функцию, которая будет применена к текущему значению.

Существует еще несколько функций и макросов, которые позволяют временно изменить базовое
значение -- =with-redefs= & =with-redefs-fn=.  Эти макросы в основном используются в
тестах, для временного переопределения функций и переменных.

*** Локальные переменные

Кроме того, поддерживается возможность использования локальных переменных в "императивном"
коде.  Для этого, определен макрос =with-local-vars=, который позволяет определить
несколько переменных и работать с ними с помощью =var-get= (или =@=) & =var-set=.  Хотя
это не самый лучший способ использования Clojure.

В качестве примера можно привести императивную реализацию факториала (пример с
[[http://clojuredocs.org/clojure_core/1.2.0/clojure.core/with-local-vars][clojuredocs]]):

#+BEGIN_SRC clojure
(defn factorial [x]
  (with-local-vars [acc 1, cnt x]
    (while (> @cnt 0)
      (var-set acc (* @acc @cnt))
      (var-set cnt (dec @cnt)))
    @acc))
#+END_SRC

** Валидаторы и наблюдатели

Ссылки, атомы, агенты и vars имеют общую функциональность - возможность задания
функций-валидаторов для проверки значений устанавливаемых в процессе изменения, а также
возможность задания функций-наблюдателей которые будут вызываться при изменении значений.

Функции валидаторы могут использоваться с ссылками, агентами, атомами и vars.
Функция-валидатор будет получать каждое новое устанавливаемое состояние и должна вернуть
=false= или сгенерировать исключение если состояние неприемлимо.  Функция-валидатор
принимает только один параметр, и не должна иметь побочных эффектов.  Например:

#+BEGIN_SRC clojure
user=> (def a (atom 2))
user=> (set-validator! a pos?)
user=> (swap! a dec)
1
user=> (swap! a dec)
IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
#+END_SRC

Вы можете установить функцию-валидатор 2-мя способами: используя функцию =set-validator!=
передав ей объект и функцию-валидатор (или =nil= если вы хотите убрать валидатор), или
используя параметр =:validator= при создании объекта (для всех кроме vars).  В момент
установки, функция-валидатор будет вызвана для текущего состояния объекта, и в том случае
если оно не прошло проверку, то будет сгенерировано исключение и функция-валидатор не
будет установлена.  Вы также можете получить текущую функцию-валидатор с помощью
=get-validator= -- это полезно в тех случаях, когда вы хотите времено изменить
функцию-валидатор.

Кроме задания функций-валидаторов, вы также можете задать и функции-наблюдатели, которые
также будут вызваны при изменении данных.  В отличии от функций-валидаторов, вы можете
задать сколько угодно функций-наблюдателей для одного объекта.  

Добавление функции-наблюдателя производится с помощью функции =add-watch= - ей передается
3 параметра: объект к которому надо добавить функцию-наблюдатель, уникальный идентификатор
для данной функции, а также саму функцию-наблюдатель.  

Функция-наблюдатель принимает 4 параметра:  уникальный идентификатор функции-наблюдателя,
объект к которому она применена, а также старое и новое состояние объекта.  Самый
последний параметр нужен, поскольку состояние объекта может измениться в промежутке между
изменением и вызовом функции.  

#+BEGIN_SRC clojure
user=> (def a (atom 1))
#'user/a
user=> (add-watch a "watch 1: " (fn [k r o n] (println k r o n)))
#<Atom@2b36b44e: 1>
user=> (add-watch a "watch 2: " (fn [k r o n] (println k r o n)))
#<Atom@2b36b44e: 1>
user=> (swap! a inc)
watch 1:  #<Atom@2b36b44e: 2> 1 2
watch 2:  #<Atom@2b36b44e: 2> 1 2
2
#+END_SRC

Для агентов, функция-наблюдатель вызывается синхронно в контексте выполнения потока
агента.  Для vars функция-наблюдатель будет вызвана только в том случае, когда изменяется
"базовое значение", а не в потоке выполнения.

#+BEGIN_SRC clojure
user=> (def ^:dynamic b 1)
user=> (add-watch (var b) "dynamic: " (fn [k r o n] (println k r o n)))
user=> (alter-var-root (var b) (constantly 42))
dynamic:  #'user/b 1 42
42
user=> (binding [b 10] (println b))
10
nil
#+END_SRC

Если вам больше не нужна функция-наблюдатель, то вы можете удалить ее с помощью функци
=remove-watch=, которой надо передать объект и уникальный идентификатор, который был
передан при добавлении наблюдателя.


** Разное...


*Стоит также упомянуть transients, но об этом мы поговорим чуть позже*

*также упомянуть mutable fields в deftype?*



* Параллельное и конкуретное программирование

 - [-] Параллельное программирование
   - [X] Встроенные примитивы - pmap, pcalls, ...
   - [X] futures
   - [X] promises
   - [X] delays
   - [ ] =locking= & other low-level primitives
   - [ ] Использование средств JVM - threads, etc.

Но поддержка конкуретного и параллельного программирования в Clojure не ограничивается
только ссылками, агентами, атомами и vars.  Имеется набор средств для параллельного
выполнения кода, координации между потоками выполнения, отложенного выполнения кода, и
т.п.  Кроме того, Clojure предоставляет полный доступ к средствам, реализованным в Java
(треды, локи), включая также некоторые высокоуровневые конструкции в самом языке.

** Параллельное выполнение кода

В стандартной библиотеке имеется несколько функций предназначенных для параллельного
выполнения кода (стоит отметить что эти функции реализованы на базе =future= которые будут
обсуждаться далее):
 - =pmap= -- это параллельный вариант функции =map=, который может использоваться в тех
   случаях, когда функция-параметр не имеет побочных эффектов, и требует достаточно
   больших затрат на вычисление -- эти затраты должны быть больше чем затраты на запуск
   нового потока, иначе выши параллельные вычисления будут медленее чем последовательное
   выполнение в =map=.  Подобно =map=, эта функция является полу-ленивой -- она не
   вычисляет результат полностью, но будет вычислять части результата по мере надобности.
 - Функция =pcalls= позволяет вычислить результат нескольких функций (которые не принимают
   аргументы) в параллельном режиме, возвращая ленивую последовательность их результатов в
   качестве результата выполнения функции.
 - Функция =pvalues= похожа на =pcalls=, но только вы указываете не функции, а выражения.
   В остальном, поведение точно такое же.

Давайте рассмотрим несколько примеров.  Например, для =pmap=, если мы определим следующую
"медленную" функцию, и применим ее к последовательности используя =map= & =pmap=.  В
первом случае, функция будет выполнена за 12 секунд (4 элемента x 3 секунды задержки), в
то время как во втором случае, функция будет выполнена примерно за 3 секунды - за счет
параллельного выполнения кода (заметьте, что нам нужно использовать =doall= чтобы
заставить Clojure вычислить результат).

#+BEGIN_SRC clojure
user=> (defn long-running-job [n]
          (Thread/sleep 3000)
          (+ n 10))

user=> (time (doall (map long-running-job (range 4))))
"Elapsed time: 12000.662614 msecs"
(10 11 12 13)
user=> (time (doall (pmap long-running-job (range 4))))
"Elapsed time: 3001.826403 msecs"
(10 11 12 13)
#+END_SRC

А вот небольшой пример для =pvalues=:

#+BEGIN_SRC clojure
user=> (time (doall (pvalues (do (Thread/sleep 3000) 1) (do (Thread/sleep 3000) 2) (do (Thread/sleep 3000) 3))))
"Elapsed time: 3000.826403 msecs"
#+END_SRC

** Futures

=future= позволяет программисту выделить некоторый код в отдельный поток выполнения,
который выполняется параллельно с основным кодом.  Результат выполнения =future= затем
сохраняется, и может быть получен с помощью операции =deref= (=@=).  Эта операция может
заблокировать выполнение основного кода, если работа =future= еще не завершилась -- в этом
=future= похож на =promise=, который описан ниже.  Значение, установленное при выполнении
=future= сохраняется, и при последующих обращениях к нему, возвращается сразу, без
вычисления.  Рассмотрим простой пример:

#+BEGIN_SRC clojure
user=> (def future-test 
            (future (do (Thread/sleep 10000) 
                    :finished)))
user=> @future-test ;; будет ждать пока выражение не вычислится
:finished
user=> @future-test ;; сразу вернет значение
:finished
#+END_SRC

Тут создается объект =future=, в котором выполняется задержка на 10 секунд, а затем
устанавливается значение =:finished=.  Если мы обратимся к объекту =future-test= до
завершения операции, то мы будем ожидать завершения указанного блока кода.

Для работы с futures имеется много дополнительных функций:
 - с помощью функций =future-done?= или =realized?= (эта функция работает также и для
   delays & promises) вы можете проверить закончилось ли выполнение кода -- это позволяет
   избежать блокирования в случае обращения к еще не закончившейся операции.
 - с помощью функции =future-cancel= вы можете отменить выполнение кода
 - с помощью функции =future-cancelled?= -- проверить, не была ли отменена операция
 - =future?= позволяет вам проверить - не является ли данный объект future

** Delays

Существуют ситуации, когда нам надо произвести обработку данных, но некоторые результаты
(например, мы возвращаем сложную структуру данных) не всегда используются, так что не
стоит тратить время на их вычисление.  Для этого, в Clojure (также как и в других языках)
имеется возможность создания delays, когда выполнение кода откладывается до момента когда
нам нужен результат.  После того, как код будет выполнен, его результат будет закеширован
и все последующие обращения к delay, будут возвращать этот результат (также как и в
futures).

Создать delay очень просто -- оберните нужные выражения в макрос =delay=, и присвойте его
какой-либо переменной (или верните вместе с другими результатами).  Если вам понадобится
значение, то воспользуйтесь =@= или =deref= чтобы извлечь его из =delay=.

Если вы хотите проверить, был ли результат уже вычислен, то вы можете воспользоваться
функцией =realized?=, которая вернет =true= если вычисление уже было завершено.  Кроме
того, вы также можете форсировать вычисление delay с помощью функции =force=.

Вот небольшой пример использования delays:

#+BEGIN_SRC clojure
user=> (defn use-delays [x]
         {:result (delay (println "Evaluating result..." x) x)
          :some-info true})

user=> (def a (use-delays 10))
user=> a
{:result #<Delay@259c3236: :pending>, :some-info true}
user=> @(:result a) ;; выполняется весь код delay
Evaluating result... 10
10
user=> @(:result a) ;; возвращается только результат
10
user=> (:result a)
<Delay@259c3236: 10>
#+END_SRC

В данном случае, поле =:result= будет вычислено только когда это потребуется.   Как вы
видите, вычисление произойдет только один раз, а затем только конечный результат будет
возвращен пользователю.

** Promises

Иногда возникают ситуации, когда один поток исполнения должен передать какие-то данные
другому.  Это может быть организовано с помощью =promise=.  Общая схема работы следующая:
в одном потоке выполнения вы создаете некоторый объект с помощью =promise=, выполняете
работу и затем с помощью =deliver= устанавливаете значение объекта.  Результат,
сохраненный в объекте, может быть получен с помощью операции =deref= (краткая форма =@=) и
не может быть изменен после установки с помощью =deliver=. 

 Но если вы попробуете обратиться к значению, сохраненному в объекте, до того, как оно
будет установлено, то ваш поток выполнения будет заблокирован, и возобновит работу только
после установки значения.  Однако после того как значение было установлено, его получение
будет производиться уже без выполнения кода, использующегося для его вычисления.

Вот небольшой пример:

#+BEGIN_SRC clojure
(def p (promise))
(do (future
     (Thread/sleep 5000)
     (deliver p :fred))
 @p)
#+END_SRC

В первой строке мы создаем объект =p=, который затем используется для синхронизации в блоке
=do=.  Если мы выполним код в блоке =do=, то выполнение затормозится на 5 секунд, поскольку
поток выполнения, созданный =future=, еще не установил значение.  А после окончания ожидания
и установки значения с помощью =deliver=, операция =@p= сможет получить установленное значение
равное =:fred=.  Если мы попробуем выполнить операцию =@p= еще раз, то мы сразу получим
установленное значение.

Чтобы избежать блокировки если значение еще не установлено, вы можете возпользоваться
функцией =realized?= которая вернет =true= только если значение уже было установлено
(также как и для futures & delays).

** Средства JVM

=locking=

threads, etc.

* Related topics

 - [ ] Related topics (http://adambard.com/blog/clojure-concurrency-smorgasbord/)
   - [ ] Reducers
   - [ ] avout ?
   - [ ] clojure-hadoop + [[http://blog.cloudera.com/blog/2013/12/write-mapreduce-jobs-in-idiomatic-clojure-with-parkour/][Parkour]] + [[https://github.com/Netflix/PigPen][PigPen]] ?
   - [ ] [[http://puniverse.github.io/pulsar/][Pulsar]]
   - [ ] [[https://github.com/ztellman/lamina][Lamina]] (http://adambard.com/blog/why-clojure-part-2-async-magic/)
   - [ ] mention core.async (http://stuartsierra.com/2013/12/08/parallel-processing-with-core-async)



** Ресурсы

 - http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey
 - http://java.ociweb.com/mark/clojure/article.html
 - Clojure Programming by Chas Emerick, Brian Carper, Christophe Grand. O'Reilly, 2012


